#!/usr/bin/env python3
"""
Build script that bundles src/ modules into a single standalone my_solution.py.

This script:
1. Reads all .py files from src/ directory
2. Concatenates them with the required PEP 723 metadata
3. Outputs my_solution.py as an executable script
"""

import os
import stat
from pathlib import Path

# PEP 723 inline script metadata
SHEBANG = "#!/usr/bin/env -S uv run --script"
SCRIPT_METADATA = """\
# /// script
# requires-python = ">=3.14"
# dependencies = []
# ///
"""

# Directories
PROJECT_ROOT = Path(__file__).parent
SRC_DIR = PROJECT_ROOT / "src"
OUTPUT_FILE = PROJECT_ROOT / "my_solution.py"


def collect_source_files() -> list[Path]:
    """Collect all Python files from src/ directory in sorted order."""
    source_files = []
    for py_file in sorted(SRC_DIR.glob("*.py")):
        # Skip __init__.py as it's typically just for package marking
        if py_file.name == "__init__.py":
            continue
        source_files.append(py_file)
    return source_files


def read_file_content(file_path: Path) -> str:
    """Read and return the content of a Python file, stripping module docstrings."""
    with open(file_path, "r", encoding="utf-8") as f:
        content = f.read()
    return content


def build_solution() -> None:
    """Build the my_solution.py file from src/ modules."""
    print(f"Building {OUTPUT_FILE.name}...")

    # Collect source files
    source_files = collect_source_files()
    print(f"Found {len(source_files)} source file(s) in src/")

    # Build the output content
    parts = [
        SHEBANG,
        SCRIPT_METADATA,
        "# Auto-generated by build.py - Do not edit directly",
        "# Edit source files in src/ and run build.py to regenerate",
        "",
    ]

    # Append each source file's content
    for src_file in source_files:
        content = read_file_content(src_file)
        parts.append(f"# === {src_file.name} ===")
        parts.append(content)
        parts.append("")
        print(f"  Added: {src_file.name}")

    # Add main entry point placeholder
    parts.append("")
    parts.append('if __name__ == "__main__":')
    parts.append("    pass  # TODO: Implement main entry point")
    parts.append("")

    # Write the output file
    output_content = "\n".join(parts)
    with open(OUTPUT_FILE, "w", encoding="utf-8") as f:
        f.write(output_content)

    # Make executable
    current_mode = os.stat(OUTPUT_FILE).st_mode
    os.chmod(OUTPUT_FILE, current_mode | stat.S_IXUSR | stat.S_IXGRP | stat.S_IXOTH)

    print(f"Successfully built {OUTPUT_FILE.name}")
    print(f"  Size: {OUTPUT_FILE.stat().st_size} bytes")
    print(f"  Executable: Yes")


if __name__ == "__main__":
    build_solution()
